# Notes for Introduction

“When I use a word, it means just what I choose it to mean — neither more nor less.” - Alice in Wonderland

Simple art above each chapter title? Like 10mm tall and \textwidth across?

This is a metachapter. What is meta-?

https://www.standoutbooks.com/nail-non-fiction-introduction/

The hook starts here. Why should the reader care?
Five reasons to read this book: 1. It is a work of passion, born out of a consuming and frenetic obsession, a labor of love; 2. It is painstakingly crafted, like a sculpture hewn from granite, every sentence carefully constructed, every word meticulously chosen; 3. It is a work written in the midst of a deep depression, and it serves as a guide to those who may experience the same feelings of self-doubt; 4. It is a distillation of some very difficult and important ideas that you have encountered and will undoubtedly encounter again; 5. It's short and tries not to waste your time...
However, there is a reason that is bigger than all of these...

The computer is the most important invention since the printing press. It is a game changer for mankind. The amount of science being done now is enormous compared to what was being done in, for example, Newton's time. Back then, there were very few scientists, and they used simple tools. The body of human knowledge started kicking into gear at the turn of the 20th century, and it took off like a rocket with the conceptualization and implementation of general-purpose computers. Before we did a few calculations a minute on a slide rule. Now, consumer CPUs can do \textit{billions of calculations per second} and supercomputers are well into the territory of \textit{quadrillions}. Human life has been immensely altered by computers.
Computers are everywhere today. They are essential to modern life, and they will only become more essential. Thus, they are worth understanding.
Computers are complicated, but they are built on simpler principles that were discovered incrementally as humanity gained knowledge. To someone who is ignorant of these earlier ideas, computers look like magic. Some programmers think that computers are magic, and yet they can still program, thanks to software abstraction. However, you will reach a conceptual limit if you rely on abstractions.
As technology gets more complicated, it gets harder to understand it without this intuitive, foundational knowledge. If you see yourself utilizing computers frequently for the remainder of your life, the time to learn about them is now.
The book gets more programming-oriented as it goes on. I am hoping that the book as a whole is compelling enough that you will not notice it. Even if programming does not interest you, the theoretical parts of the book will teach you how things work and the application parts will teach you how to make great things. If you are not interested in that, you should be.

What is this thing? A book? A textbook? A work of non-fiction? A list? A guide? A handbook? I think it is all of those things.
A guide to life in the Information Age.

It's a book about programming, and a guide for software engineering interviews, but it's more than that. I think it will be interesting and useful for anyone who wants to create and analyze things effectively.

Technically, a book is a physical medium that acts as the vessel for a \textit{text}, a written work, a determinate sequence of abstract symbols. Thus, I will refer to this work hencefore as a text.
What is the computer equivalent of a text? A text file, an abstract sequence of numbers. Do computer files exist? They manifest in physical reality as voltage levels, yes. However, the recognition of these voltages as elements of a pattern is conceptual. This is the case for all patterns, for all things more complex than singular, indivisible objects. So the abstract, informational content of a story does not exist in physical reality, but a computer can contain an electrical phenomenon within its memory that can be interpreted as the content, given the appropriate algorithm.

----------------------------------------

Use short paragraphs. Be concise. Make it conversational.
Make it inspiring. Make it motivational. Make it sound accessible.
A subsection called administrivia for book-structure information.

Discuss the goal of this guide. Discuss why someone might want to read it.
Discuss why content was chosen and why it is ordered the way it is.
Discuss why certain topics were left out.
Give a section by section overview. Raise some of the central questions.
Give a warning for the very theoretical early sections. Or at least assure readers that things will become more applied as the guide progresses.
Discuss the title. Intuition. Definitions in my own words - "if you know something's name, you have power over it." True name, mysticism.
Make your own guide!

--- METHODOLOGY ------------------------

I begin writing this so that I could understand it. Then, it got big enough that I thought it could be of use to others, so I started to write it in such a way that someone with less formal education than me could understand it. Then, I realized that in order to really get it, I had to write about these complex topics in such a way that someone outside of CS could feasibly understand it, given enough time and drive. I wanted to explain the insights one can glean from higher mathematics and theoretical computer science, and I wanted to do it in such a way that it was really easy to understand. This is intuitive understanding. Semantic understanding. In hacker terms, to grok something.
The words on the page will not teach the material to you. They are simply there to guide your thoughts toward understanding. You have to spend time in thought to foster intuition.
You might find the tone of the book to be conversational. This is because I don't know how to teach in any way besides conversation.
More information does not mean more understanding. File sizes denote information - movies vs. books.
This guide began as a study list for software interviews. What does it mean to study for a software interview? Is it just doing a bunch of sample problems? How prepared should you be? Is the goal simply to receive an offer or to be a truly excellent candidate? I would argue that it is better to pursue the latter, if possible, because it means you are building yourself, not just building a temporary performance that will be showcased at interviews. You make yourself an asset. Also, as long as you have only a surface-level understanding, you will always feel like a fraud who knowledge is fragile and constantly waning. And it will only be a matter of time before people notice your imcompetence and fire you.
The question should not be "How do I get a competitive software engineering job?" It should instead be "What makes a truly excellent software engineer?"
While jargon is confusing to people who are not 'in the know', it is usually very descriptive. It paints a very precise picture, if you know how to differentiate similar terms. The English words that are used are often quite apt. Differentiation and integration as examples.
There are a lot of jargon terms in computer science, and a lot of them are very similar. This guide also serves as a personal dictionary of sorts.
This book champions a semantic approach to the content covered. I personally cannot be satisfied with only equations and hand-waving explanations for what they represent. This does not mean that it focuses on applied math rather than pure math. On the contrary, there is a fair amount of pure math here. However, good teachers tend to plot pure mathematical structures and explain them with metaphors to make them familiar. The philosophy here is that in order to learn something new, you must be able to compare it to something you already understand. If a non-trivial topic is 100 percent foreign to you, you can't learn it, no matter how hard you try. "Words in a dictionary are defined in terms of words. If you don't know any words at all, a dictionary is useless to you."
This book is written in a poetic/oratory style. It flows like a speech that is meant to be read aloud. I encourage you to do so.
The book is slanted toward imperative programming, specifically toward OOP. This is because most software engineering is done in OOP languages. OOP is also less abstract and thus more beginner-friendly. Declarative programming and functional languages are discussed with a decent level of detail, but OOP is the default here. For example, the implementation chapter explores Java.

What makes this book different from most textboooks is that it starts from first principles.
Traditional education is bottom-up (notice how particular stuff on Earth falls when it's dropped => that's because this law F_g=ma_g exists). This book uses a top-down approach (in the abstract sense, what is mass, acceleration, force, objects, motion, distance, space => given all of those ideas, we observe that the equation F_g=ma_g describes what seems to happen in this Universe). The traditional approach is syntactic, this book's approach is semantic. The "top" in this case is philosophical and mathematical theory: large-scale ideas, objects, and relations. We spend a substantial amount of time talking about these huge, fundamental concepts and how they appear in philosophy, logic, mathematics, physics, linguistics, etc. Once this information theory is built, we use our newfound mathematical insight to model computation and computational phenomena (automata, DS&A, programs). In doing so, we develop a theory of computer science. We then use this theory to understand principles of software engineering.
Bottom-up is like starting from an arche, top-down is like starting from henosis.

Why do people think they can't do math? What is so confusing about it to them? I collected some responses, thought about it, and tried to make this text as accessible as possible for those people.

Blue boxes are tangential material and out-there concepts. But they should not be considered optional. One of the great challenges of writing well is condensing the tree nature of experience into the list structure of an essay.
Make a chart with philosophy as a circle (a non-metric space) and mathematics, physics, engineering, computer science, etc. as bars (metrics spaces whose metric is academic complexity). The bars start at high-school level topics and extend to the bleeding edge of understanding. Draw two versions: what college taught me vs. what I felt like I needed to know. Syntactic understanding vs semantic understanding.
College dug deep, raw tunnels into hard earth. <Drawing of vertical lines>. Writing this book connected them all horizontally, leaving lanterns at the intersections so that one could see all the way from one end to the other. <Drawing of criss-crossing lines and nodes>. Now, picture these tunnels instead as interlocking length of fishing line. With my net woven, I can catch fish instead of floundering in the water with loose strings.

Chapters vs. sections.

Interdisciplinary, historical approach.
There are a lot of quotes. I like quotes. Plus, taking a bunch of quotes out of context (slashthrough) \textit{repurposing} quotes allows me to pretend like a bunch of smart people agree with what I am saying. And they all write a part of my book for free. Ha, suckers!
I remember the death quotes in Call of Duty 4 (quite profound in their context, especially considering it's Call of Duty). Quotes can sound profound even when you are not mature enough to really understand them (like quotes about war). "War is delightful to those who have not yet experienced it." - Erasmus. "My first wish is to see this plague of mankind, war, banished from the earth." - George Washington (and then America goes on to be in an almost perpetual state of war).
Good quotes succinctly capture the essence of a hard-to-grasp truth. Mathematical formulas are basically quotes.
This material is "advanced," but it is not inherently hard. If you perceive any material as hard, here or elsewhere, that either means that you are unfamiliar with it and you need to muse on it for a while (perhaps by covering more elementary topics first) or that it is being taught poorly.

I'm not a PhD. Most people who write textbooks are. This is still a textbook. It is meant to be educational.
I am not very old. Most people who write textbooks are older. (I learned much of this material as I was writing it. Most people who write textbooks know the material beforehand.) However, I think this is a benefit in some sense because I am not so far removed from my target audience.
Despite the style being markedly different than that of a typical textbook, this is still a textbook. There are no exercises. In lieu of formal exercises, read the book out loud, 25slower than you would normally, and take breaks frequently to allow yourself some time to ponder what you have read.

People should catalog their knowledge in a format that they are proud of. We spend so much time and effort learning, and then we just accept that we will forget the vast majority of it. I remember cramming for my linear algebra final (a class I had no business taking in my first semester of college). A few hours before the test, I was drawing some matrices on a whiteboard and I thought about how that point in time would likely mark the peak of my understanding of linear algebra. Beyond that point, my familiarity with all of that material would slow die. And I thought that that was very sad. I also more recently read that many software engineers forget most of what they learned about CS. That is also very sad.
Italics are used to mark emphasis, but the kind of emphasis marked depends on context. Sometimes, an italicized word is a \textit{keyword}, which means that it is a technical term and that I want you pause for a half-second to absorb its meaning. Other times, the italics merely denote a \emph{vocal cue for emphasis}. Words from languages other than English are also italicized.
Content will be presented in a culturally neutral and timeless way that does not assume a great deal of prior knowledge.
The book tries to get the point across that there is more than one way to think about things and that knowledge is built on assumptions, including the body of knowledge called computer science. While we must work within a box, we should strive to remind ourselves periodically that we are, indeed, in a box and that there exist methods of thinking outside of it. The theories and models we use today may simply be the predecessors of theories and models to come. The topics of discussion, however, are eternal.

The abbreviations i.e. and e.g. are used frequently in this book. What do those mean?
If there's a word you don't know, just look up the definition and keep going. That's basically how I wrote this book.
There are times when I speak very precisely and times where I am more casual. I believe it will be easy to tell which mode I am in from context. If you see a lot of italicized keywords and dense sentences (and bullet points), that probably means I am speaking precisely. If you see poetic language, absolute statements, or contractions, that probably means I am speaking casually.
This document uses A4 paper size. Print it out and put some staples in it if you would like a hard copy. If you are a US Letter-using heathen, there is also a US Letter version available for your convenience. (And in the US Letter version, write something else).
You may be interested in seeing the LaTeX code that I wrote to compile this book. You can find it at ...
The pronoun "we" may refer to you, the reader, and me, the author, taking this journey through the text together. It is also sometimes used to refer to humanity as a whole.

"Looking at a bird he says, 'Do you know what that bird is? It's a brown throated thrush, but in Portuguese, it's a... in Italian, a...' he says "in Chinese, it's a... in Japanese, a...,' et cetera. 'Now,' he says, 'you'll know absolutely nothing whatsoever about the bird. You only know about humans in different places and what they call the bird. Now,' he says, 'let's look at the bird." - Richard Feynman (recalling his father, The Pleasure of Finding Things Out)

